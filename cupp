#!/usr/bin/python3
#
#  [Program]
#
#  CUPP
#  Common User Passwords Profiler
#
#  [Author]
#
#  Muris Kurgas aka j0rgan
#  j0rgan [at] remote-exploit [dot] org
#  http://www.remote-exploit.org
#  http://www.azuzi.me
#
#  [License]
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  See 'LICENSE' for more information.

import argparse
import configparser
import csv
import functools
import gzip
import os
import sys
import urllib.error
import urllib.parse
import urllib.request
import time

__author__ = "Mebus"
__license__ = "GPL"
__version__ = "3.3.1" # Incremented version for changes

CONFIG = {}


def read_config(filename):
    """Read the given configuration file and update global variables to reflect
    changes (CONFIG)."""

    if os.path.isfile(filename):
        config = configparser.ConfigParser()
        config.read(filename)

        CONFIG["global"] = {
            "years": config.get("years", "years", fallback="").split(","),
            "chars": config.get("specialchars", "chars", fallback="").split(","),
            "numfrom": config.getint("nums", "from", fallback=0),
            "numto": config.getint("nums", "to", fallback=100),
            "wcfrom": config.getint("nums", "wcfrom", fallback=5),
            "wcto": config.getint("nums", "wcto", fallback=12),
            "threshold": config.getint("nums", "threshold", fallback=200),
            "alectourl": config.get("alecto", "alectourl", fallback=""),
            "dicturl": config.get("downloader", "dicturl", fallback=""),
        }
        CONFIG["global"]["years"] = [y for y in CONFIG["global"]["years"] if y.strip()]
        CONFIG["global"]["chars"] = [c for c in CONFIG["global"]["chars"] if c.strip()]


        leet = functools.partial(config.get, "leet")
        leetc = {}
        # Provide default leet letters if section or letters are missing
        default_leet_map = {"a": "4", "i": "1", "e": "3", "t": "7", "o": "0", "s": "5", "g": "9", "z": "2"}
        if config.has_section("leet"):
            for letter in default_leet_map.keys():
                leetc[letter] = config.get("leet", letter, fallback=default_leet_map[letter])
        else:
            leetc = default_leet_map
        CONFIG["LEET"] = leetc
        
        custom_patterns_cfg = {}
        if config.has_section("custom_patterns"):
            custom_patterns_cfg["enable_word_duplication"] = config.get("custom_patterns", "enable_word_duplication", fallback="no")
            custom_patterns_cfg["duplication_styles"] = config.get("custom_patterns", "duplication_styles", fallback="simple,underscore,camelcase")
            custom_patterns_cfg["enable_common_patterns"] = config.get("custom_patterns", "enable_common_patterns", fallback="no")
            custom_patterns_cfg["enable_keyboard_patterns"] = config.get("custom_patterns", "enable_keyboard_patterns", fallback="no")
            custom_patterns_cfg["keyboard_alpha_patterns"] = config.get("custom_patterns", "keyboard_alpha_patterns", fallback="qwerty,asdf,zxcv")
            custom_patterns_cfg["keyboard_num_patterns"] = config.get("custom_patterns", "keyboard_num_patterns", fallback="123,12345,0987")
            custom_patterns_cfg["keyboard_pattern_position"] = config.get("custom_patterns", "keyboard_pattern_position", fallback="suffix,prefix")
            custom_patterns_cfg["enable_repeating_char_pattern"] = config.get("custom_patterns", "enable_repeating_char_pattern", fallback="no")
            custom_patterns_cfg["repeating_chars_for_pattern"] = config.get("custom_patterns", "repeating_chars_for_pattern", fallback="0")
            custom_patterns_cfg["max_char_repetitions_for_pattern"] = config.getint("custom_patterns", "max_char_repetitions_for_pattern", fallback=3)
        else: # Default values if section is missing
            custom_patterns_cfg["enable_word_duplication"] = "no"
            custom_patterns_cfg["duplication_styles"] = "simple,underscore,camelcase"
            custom_patterns_cfg["enable_common_patterns"] = "no"
            custom_patterns_cfg["enable_keyboard_patterns"] = "no"
            custom_patterns_cfg["keyboard_alpha_patterns"] = "qwerty,asdf,zxcv"
            custom_patterns_cfg["keyboard_num_patterns"] = "123,12345,0987"
            custom_patterns_cfg["keyboard_pattern_position"] = "suffix,prefix"
            custom_patterns_cfg["enable_repeating_char_pattern"] = "no"
            custom_patterns_cfg["repeating_chars_for_pattern"] = "0"
            custom_patterns_cfg["max_char_repetitions_for_pattern"] = 3
        CONFIG["custom_patterns"] = custom_patterns_cfg
        return True
    else:
        print(f"Configuration file {filename} not found!")
        sys.exit("Exiting.")
        # return False # Unreachable due to sys.exit()

def make_leet(x):
    """convert string to leet"""
    if not isinstance(x, str): # Ensure x is a string
        return x
    for letter, leetletter in CONFIG.get("LEET", {}).items():
        x = x.replace(letter, leetletter)
    return x

def concats(seq, start, stop):
    for mystr in seq:
        if not mystr: continue # Skip empty strings
        for num in range(start, stop + 1): # Make 'stop' inclusive
            yield mystr + str(num)

def komb(seq, start, special=""):
    for mystr in seq:
        if not mystr: continue
        for mystr1 in start:
            if not mystr1: continue
            yield mystr + special + mystr1

def print_to_file(filename, unique_list_finished):
    try:
        with open(filename, "w", encoding='utf-8') as f: # Added encoding
            unique_list_finished.sort() # Sort before writing
            f.write(os.linesep.join(unique_list_finished))
        
        lines = len(unique_list_finished) # More efficient way to count lines
        print(
            f"[+] Saving dictionary to \033[1;31m{filename}\033[1;m, "
            f"counting \033[1;31m{lines} words.\033[1;m"
        )
        
        inspect = input("> Hyperspeed Print? (Y/n) : ").lower()
        if inspect == "y":
            # Hyperspeed print can be disruptive, consider removing or making it optional
            # For now, keeping original logic but with error handling
            try:
                with open(filename, "r+", encoding='utf-8') as wlist:
                    data = wlist.readlines()
                    for line in data:
                        print(f"\033[1;32m[{os.path.basename(filename)}] \033[1;33m{line.strip()}") # Use os.path.basename
                        time.sleep(0.0001) # Reduced sleep time
                        if os.name == 'posix': # Clear screen for unix-like
                            os.system("clear")
                        elif os.name == 'nt': # Clear screen for windows
                            os.system("cls")
            except Exception as e:
                print(f"[ERROR] during Hyperspeed Print: {e}")
        
        print(
            f"[+] Now load your pistolero with \033[1;31m{filename}\033[1;m and shoot! Good luck!"
        )
    except IOError as e:
        print(f"[!] Error writing to file {filename}: {e}")
    except Exception as e:
        print(f"[!] An unexpected error occurred in print_to_file: {e}")


def version():
    """Display version"""
    print(f"\r\n	\033[1;31m[ cupp.py ]  {__version__}\033[1;m\r\n")
    print("	* Hacked up by j0rgan - j0rgan@remote-exploit.org")
    print("	* http://www.remote-exploit.org\r\n")
    print("	Take a look ./README.md file for more info about the program\r\n")

def apply_custom_patterns(base_words_list, profile_for_common_patterns=None):
    """
    Applies various custom patterns to a list of base words.
    profile_for_common_patterns is an optional dict, used by Common Patterns
    to get birthdate for year/number variations. If None, those specific
    variations in common patterns might be skipped or use defaults.
    """
    custom_generated_passwords = []
    custom_patterns_config = CONFIG.get("custom_patterns", {})

    # Prepare base words: lowercase and TitleCase
    # Ensure base_words_list contains actual words (non-empty strings)
    valid_base_words = [w.lower() for w in base_words_list if w and isinstance(w, str)]
    unique_base_words_for_custom_patterns = sorted(list(set(valid_base_words)))


    # 1. Word Duplication Logic
    if custom_patterns_config.get("enable_word_duplication", "no").lower() == "yes":
        dup_styles_str = custom_patterns_config.get("duplication_styles", "simple")
        dup_styles = [s.strip().lower() for s in dup_styles_str.split(',')]
        
        for word_item in unique_base_words_for_custom_patterns:
            if "simple" in dup_styles:
                custom_generated_passwords.append(word_item + word_item)
            if "underscore" in dup_styles:
                custom_generated_passwords.append(word_item + "_" + word_item)
            if "camelcase" in dup_styles:
                custom_generated_passwords.append(word_item + word_item.title())
    
    # 2. Common Password Patterns Logic
    if custom_patterns_config.get("enable_common_patterns", "no").lower() == "yes":
        words_for_common_patterns_variants = []
        for w in unique_base_words_for_custom_patterns:
            words_for_common_patterns_variants.append(w)
            words_for_common_patterns_variants.append(w.title())
        words_for_common_patterns_variants = sorted(list(set(words_for_common_patterns_variants)))

        common_pattern_numbers = [str(n) for n in range(CONFIG["global"]["numfrom"], min(CONFIG["global"]["numfrom"] + 3, CONFIG["global"]["numto"] + 1))]
        for default_num in ["1", "12", "123", "0", "7"]: 
            if default_num not in common_pattern_numbers: common_pattern_numbers.append(default_num)
        
        # Use birthdate from profile if available (for -i mode)
        birthdate_for_patterns = profile_for_common_patterns.get("birthdate", "") if profile_for_common_patterns else ""
        if birthdate_for_patterns and len(birthdate_for_patterns) == 8:
            if birthdate_for_patterns[-2:] not in common_pattern_numbers: common_pattern_numbers.append(birthdate_for_patterns[-2:])
            if birthdate_for_patterns[-4:] not in common_pattern_numbers: common_pattern_numbers.append(birthdate_for_patterns[-4:])
        common_pattern_numbers = sorted(list(set(filter(None, common_pattern_numbers))))

        common_pattern_specials = CONFIG["global"]["chars"][:3] 
        if not common_pattern_specials and CONFIG["global"]["chars"]: 
             common_pattern_specials = [c for c in CONFIG["global"]["chars"] if c][:1] 
        if not common_pattern_specials: common_pattern_specials = ['!', '@', '#'] 

        common_pattern_years = CONFIG["global"]["years"][:2] 
        if birthdate_for_patterns and len(birthdate_for_patterns) == 8:
            birth_year_full = birthdate_for_patterns[-4:]
            if birth_year_full not in common_pattern_years: common_pattern_years.append(birth_year_full)
        common_pattern_years = sorted(list(set(filter(None, common_pattern_years))))

        for word_variant in words_for_common_patterns_variants:
            for num_str in common_pattern_numbers:
                custom_generated_passwords.append(word_variant + num_str)
                for sp_char in common_pattern_specials:
                    custom_generated_passwords.append(word_variant + num_str + sp_char)
                    custom_generated_passwords.append(word_variant + sp_char + num_str)
            for year_str in common_pattern_years:
                custom_generated_passwords.append(word_variant + year_str)

    # 3. Keyboard Patterns Logic
    if custom_patterns_config.get("enable_keyboard_patterns", "no").lower() == "yes":
        words_for_kb_patterns_variants = []
        for w in unique_base_words_for_custom_patterns:
            words_for_kb_patterns_variants.append(w)
            words_for_kb_patterns_variants.append(w.title())
        words_for_kb_patterns_variants = sorted(list(set(words_for_kb_patterns_variants)))
        
        alpha_pats_str = custom_patterns_config.get("keyboard_alpha_patterns", "qwerty,asdf")
        num_pats_str = custom_patterns_config.get("keyboard_num_patterns", "123,12345")
        kb_pos_str = custom_patterns_config.get("keyboard_pattern_position", "suffix,prefix")

        all_kb_pats = [p.strip() for p in alpha_pats_str.split(',') if p.strip()] + \
                        [p.strip() for p in num_pats_str.split(',') if p.strip()]
        all_kb_pats = list(filter(None, all_kb_pats)) 

        positions = [pos.strip().lower() for pos in kb_pos_str.split(',') if pos.strip()]

        for word_variant in words_for_kb_patterns_variants:
            for kb_pattern in all_kb_pats:
                if "suffix" in positions or "both" in positions:
                    custom_generated_passwords.append(word_variant + kb_pattern)
                if "prefix" in positions or "both" in positions:
                    custom_generated_passwords.append(kb_pattern + word_variant)
    
    # 4. Word + Repeating Character Pattern Logic
    if custom_patterns_config.get("enable_repeating_char_pattern", "no").lower() == "yes":
        chars_to_repeat_str = custom_patterns_config.get("repeating_chars_for_pattern", "0")
        configured_repeating_chars = [c.strip()[0] for c in chars_to_repeat_str.split(',') if c.strip()]
        
        max_reps_cfg = custom_patterns_config.get("max_char_repetitions_for_pattern", 3)
        max_reps = int(max_reps_cfg) if isinstance(max_reps_cfg, (int, str)) and str(max_reps_cfg).isdigit() and int(max_reps_cfg) > 0 else 3


        words_for_repeating_pattern = []
        for w in unique_base_words_for_custom_patterns:
            words_for_repeating_pattern.append(w)       
            words_for_repeating_pattern.append(w.title()) 
        words_for_repeating_pattern = sorted(list(set(filter(None, words_for_repeating_pattern))))

        for word_variant in words_for_repeating_pattern:
            for char_to_rep in configured_repeating_chars:
                for i in range(1, max_reps + 1):
                    repeated_sequence = char_to_rep * i
                    custom_generated_passwords.append(word_variant + repeated_sequence)
    
    return list(set(custom_generated_passwords)) # Return unique list

def improve_dictionary(file_to_open):
    """Implementation of the -w option. Improve a dictionary by
    interactively questioning the user."""

    kombinacija = {}
    komb_unique = {}

    if not os.path.isfile(file_to_open):
        sys.exit(f"Error: file {file_to_open} does not exist.")

    cfg_global = CONFIG["global"]
    chars = cfg_global["chars"]
    years = cfg_global["years"]
    numfrom = cfg_global["numfrom"]
    numto = cfg_global["numto"]

    try:
        with open(file_to_open, "r", encoding='utf-8', errors='ignore') as fajl: # Added encoding
            listic = fajl.readlines()
    except Exception as e:
        sys.exit(f"Error reading file {file_to_open}: {e}")

    listica = [] # Base words from the input file
    for x in listic:
        listica.extend(x.strip().split()) # Use strip and extend
    listica = list(set(filter(None, [w.lower() for w in listica]))) # Unique, lowercase, non-empty words

    if not listica:
        sys.exit(f"Input file {file_to_open} is empty or contains no usable words.")

    print("\r\n      *************************************************")
    print("      *                    \033[1;31mWARNING!!!\033[1;m                 *")
    print("      *         Using large wordlists in some         *")
    print("      *       options bellow is NOT recommended!      *")
    print("      *************************************************\r\n")

    conts_q = input("> Do you want to concatenate all words from wordlist? Y/[N]: ").lower()
    if conts_q == "y" and len(listica) > cfg_global["threshold"]:
        print(f"\r\n[-] Maximum number of words for concatenation is {cfg_global['threshold']}")
        print("[-] Check configuration file for increasing this number.\r\n")
        conts_q = input("> Do you want to concatenate all words from wordlist? Y/[N]: ").lower()
    
    cont = [] # Concatenated words
    if conts_q == "y":
        # To avoid extremely large lists, perhaps limit concatenations or use a sample
        # For now, original logic for concatenation:
        if len(listica) < 100: # Arbitrary limit to prevent explosion
            for i, cont1 in enumerate(listica):
                for j, cont2 in enumerate(listica):
                    if i != j: # Avoid word + word
                        cont.append(cont1 + cont2)
            cont = list(set(cont)) # Unique concatenated words
        else:
            print("[-] Wordlist too large for full concatenation, skipping this step.")


    spechars_list = [] # List of special char combinations
    spechars_q = input("> Do you want to add special chars at the end of words? Y/[N]: ").lower()
    if spechars_q == "y" and chars:
        spechars_list.append("") # To include words without special chars
        for spec1 in chars:
            spechars_list.append(spec1)
            for spec2 in chars:
                spechars_list.append(spec1 + spec2)
                # Limit to 2 special chars for -w mode to keep it manageable, 
                # or make this configurable. For now, limit to 2.
                # for spec3 in chars:
                #     spechars_list.append(spec1 + spec2 + spec3)
        spechars_list = list(set(spechars_list))


    randnum_q = input("> Do you want to add some random numbers at the end of words? Y/[N]:").lower()
    leetmode_q = input("> Leet mode? (i.e. leet = 1337) Y/[N]: ").lower()

    # --- START: Apply Custom Patterns in -w mode ---
    # Ask user for each custom pattern type if they want to apply it
    # and also check if it's enabled in cupp.cfg
    custom_patterns_config = CONFIG.get("custom_patterns", {})
    generated_by_custom_patterns = []

    if custom_patterns_config.get("enable_word_duplication", "no").lower() == "yes":
        apply_dup_q = input("> Apply Word Duplication patterns? (e.g., wordword) Y/[N]: ").lower()
        if apply_dup_q == 'y':
            # Temporarily enable for apply_custom_patterns call
            original_dup_setting = custom_patterns_config["enable_word_duplication"]
            custom_patterns_config["enable_word_duplication"] = "yes"
            generated_by_custom_patterns.extend(apply_custom_patterns(listica))
            custom_patterns_config["enable_word_duplication"] = original_dup_setting # Reset
    
    if custom_patterns_config.get("enable_common_patterns", "no").lower() == "yes":
        apply_common_q = input("> Apply Common Password patterns? (e.g., Word123) Y/[N]: ").lower()
        if apply_common_q == 'y':
            original_common_setting = custom_patterns_config["enable_common_patterns"]
            custom_patterns_config["enable_common_patterns"] = "yes"
            # Common patterns in -w mode won't have profile birthdate, so pass None
            generated_by_custom_patterns.extend(apply_custom_patterns(listica, None)) 
            custom_patterns_config["enable_common_patterns"] = original_common_setting

    if custom_patterns_config.get("enable_keyboard_patterns", "no").lower() == "yes":
        apply_kb_q = input("> Apply Keyboard patterns? (e.g., qwertyWORD) Y/[N]: ").lower()
        if apply_kb_q == 'y':
            original_kb_setting = custom_patterns_config["enable_keyboard_patterns"]
            custom_patterns_config["enable_keyboard_patterns"] = "yes"
            generated_by_custom_patterns.extend(apply_custom_patterns(listica))
            custom_patterns_config["enable_keyboard_patterns"] = original_kb_setting

    if custom_patterns_config.get("enable_repeating_char_pattern", "no").lower() == "yes":
        apply_rep_q = input("> Apply Repeating Character patterns? (e.g., word000) Y/[N]: ").lower()
        if apply_rep_q == 'y':
            original_rep_setting = custom_patterns_config["enable_repeating_char_pattern"]
            custom_patterns_config["enable_repeating_char_pattern"] = "yes"
            generated_by_custom_patterns.extend(apply_custom_patterns(listica))
            custom_patterns_config["enable_repeating_char_pattern"] = original_rep_setting
    
    generated_by_custom_patterns = list(set(generated_by_custom_patterns)) # Unique
    # --- END: Apply Custom Patterns in -w mode ---


    # Original combinations
    # Initialize kombinacija dictionary for up to 6 keys
    for i in range(6):
        kombinacija[i] = [] # Ensure they are lists

    if years:
        kombinacija[0] = list(komb(listica, years))
        if conts_q == "y" and cont:
            kombinacija[1] = list(komb(cont, years))
    
    if spechars_q == "y" and spechars_list:
        kombinacija[2] = list(komb(listica, spechars_list))
        if conts_q == "y" and cont:
            kombinacija[3] = list(komb(cont, spechars_list))

    if randnum_q == "y":
        kombinacija[4] = list(concats(listica, numfrom, numto))
        if conts_q == "y" and cont:
            kombinacija[5] = list(concats(cont, numfrom, numto))

    print("\r\n[+] Now making a dictionary...")
    print("[+] Sorting list and removing duplicates...")

    # Process kombinacija for unique values
    for i in range(6):
        komb_unique[i] = list(set(kombinacija[i])) # Use set for uniqueness

    # Add base words and concatenated words
    komb_unique[6] = listica # Already unique and lowercased
    komb_unique[7] = cont    # Already unique if generated

    uniqlist = []
    for i in range(8): # Iterate through all collected komb_unique lists
        if i in komb_unique: # Check if key exists
             uniqlist.extend(komb_unique[i])
    
    # Add words from new custom pattern generation
    uniqlist.extend(generated_by_custom_patterns)

    unique_lista = list(set(uniqlist)) # Final unique list before leet

    unique_leet = []
    if leetmode_q == "y":
        for x_word in unique_lista:
            unique_leet.append(make_leet(x_word))
    
    unique_list_final = list(set(unique_lista + unique_leet)) # Combine and make unique

    # Word length shaping
    unique_list_finished = [
        x for x in unique_list_final
        if cfg_global["wcfrom"] <= len(x) <= cfg_global["wcto"] # Inclusive length check
    ]
    # Ensure no empty strings in the final list
    unique_list_finished = [x for x in unique_list_finished if x]


    if unique_list_finished:
        print_to_file(file_to_open + ".cupp.txt", unique_list_finished)
    else:
        print("[-] No words generated that match the criteria. Output file not created.")


def interactive():
    """Implementation of the -i switch. Interactively question the user and
    create a password dictionary file based on the answer."""

    print("\r\n[+] Insert the information about the victim to make a dictionary")
    print("[+] If you don't know all the info, just hit enter when asked! ;)\r\n")

    profile = {}

    name = input("> First Name: ").lower().strip()
    while not name: # Simplified check for empty name
        print("\r\n[-] You must enter a name at least!")
        name = input("> Name: ").lower().strip()
    profile["name"] = name

    profile["surname"] = input("> Surname: ").lower().strip()
    profile["nick"] = input("> Nickname: ").lower().strip()
    
    birthdate = input("> Birthdate (DDMMYYYY): ").strip()
    while birthdate and len(birthdate) != 8 or (birthdate and not birthdate.isdigit()):
        print("\r\n[-] You must enter 8 digits for birthday (DDMMYYYY) or leave blank!")
        birthdate = input("> Birthdate (DDMMYYYY): ").strip()
    profile["birthdate"] = birthdate

    print("\r\n")

    profile["wife"] = input("> Partner's name: ").lower().strip() # Corrected typo
    profile["wifen"] = input("> Partner's nickname: ").lower().strip()
    wifeb = input("> Partner's birthdate (DDMMYYYY): ").strip()
    while wifeb and len(wifeb) != 8 or (wifeb and not wifeb.isdigit()):
        print("\r\n[-] You must enter 8 digits for partner's birthday (DDMMYYYY) or leave blank!")
        wifeb = input("> Partner's birthdate (DDMMYYYY): ").strip()
    profile["wifeb"] = wifeb
    print("\r\n")

    profile["kid"] = input("> Child's name: ").lower().strip()
    profile["kidn"] = input("> Child's nickname: ").lower().strip()
    kidb = input("> Child's birthdate (DDMMYYYY): ").strip()
    while kidb and len(kidb) != 8 or (kidb and not kidb.isdigit()):
        print("\r\n[-] You must enter 8 digits for child's birthday (DDMMYYYY) or leave blank!")
        kidb = input("> Child's birthdate (DDMMYYYY): ").strip()
    profile["kidb"] = kidb
    print("\r\n")

    profile["pet"] = input("> Pet's name: ").lower().strip()
    profile["company"] = input("> Company name: ").lower().strip()
    print("\r\n")

    profile["words"] = [] # Initialize as empty list
    words1 = input("> Do you want to add some key words about the victim? Y/[N]: ").lower()
    if words1 == "y":
        words2_input = input(
            "> Please enter the words, separated by comma. [i.e. hacker,juice,black], spaces will be removed: "
        )
        profile["words"] = [w.strip().lower() for w in words2_input.split(',') if w.strip()] # Cleaned up keyword input

    profile["spechars1"] = input("> Do you want to add special chars at the end of words? Y/[N]: ").lower()
    profile["randnum"] = input("> Do you want to add some random numbers at the end of words? Y/[N]:").lower()
    profile["leetmode"] = input("> Leet mode? (i.e. leet = 1337) Y/[N]: ").lower()

    generate_wordlist_from_profile(profile)


def generate_wordlist_from_profile(profile):
    """ Generates a wordlist from a given profile """

    cfg_global = CONFIG["global"]
    chars = cfg_global["chars"]
    years = cfg_global["years"]
    numfrom = cfg_global["numfrom"]
    numto = cfg_global["numto"]

    profile_spechars = [] # Renamed to avoid conflict with global 'chars'
    if profile.get("spechars1") == "y" and chars:
        profile_spechars.append("") # For words without special chars added by this logic
        for spec1 in chars:
            profile_spechars.append(spec1)
            for spec2 in chars:
                profile_spechars.append(spec1 + spec2)
                for spec3 in chars: # Consider limiting this for performance if many special chars
                    profile_spechars.append(spec1 + spec2 + spec3)
        profile_spechars = list(set(profile_spechars))


    print("\r\n[+] Now making a dictionary...")

    # --- START: Prepare base words for custom patterns from profile ---
    raw_base_words_for_custom_patterns = []
    for key in ["name", "surname", "nick", "wife", "wifen", "kid", "kidn", "pet", "company"]:
        val = profile.get(key)
        if val and isinstance(val, str) and val.strip():
            raw_base_words_for_custom_patterns.append(val.lower()) 
    
    profile_keywords = profile.get("words", []) # Already lowercased and stripped during input
    raw_base_words_for_custom_patterns.extend(profile_keywords)
    # --- END: Prepare base words for custom patterns from profile ---
    
    # Call the centralized custom pattern generation function
    # Pass the 'profile' dict so Common Patterns can use birthdate if available
    custom_generated_passwords = apply_custom_patterns(raw_base_words_for_custom_patterns, profile)


    # Date processing (ensure dates are valid before slicing)
    birthdate = profile.get("birthdate", "")
    birthdate_yy = birthdate[-2:] if len(birthdate) == 8 and birthdate.isdigit() else ""
    birthdate_yyyy = birthdate[-4:] if len(birthdate) == 8 and birthdate.isdigit() else ""
    birthdate_dd = birthdate[:2] if len(birthdate) == 8 and birthdate.isdigit() else ""
    birthdate_mm = birthdate[2:4] if len(birthdate) == 8 and birthdate.isdigit() else ""
    # Remove xd, xm, yyy as they are less common and add complexity; focus on core parts
    
    wifeb = profile.get("wifeb", "")
    wifeb_yy = wifeb[-2:] if len(wifeb) == 8 and wifeb.isdigit() else ""
    wifeb_yyyy = wifeb[-4:] if len(wifeb) == 8 and wifeb.isdigit() else ""
    wifeb_dd = wifeb[:2] if len(wifeb) == 8 and wifeb.isdigit() else ""
    wifeb_mm = wifeb[2:4] if len(wifeb) == 8 and wifeb.isdigit() else ""

    kidb = profile.get("kidb", "")
    kidb_yy = kidb[-2:] if len(kidb) == 8 and kidb.isdigit() else ""
    kidb_yyyy = kidb[-4:] if len(kidb) == 8 and kidb.isdigit() else ""
    kidb_dd = kidb[:2] if len(kidb) == 8 and kidb.isdigit() else ""
    kidb_mm = kidb[2:4] if len(kidb) == 8 and kidb.isdigit() else ""

    # Case variations
    nameup = profile.get("name", "").title()
    surnameup = profile.get("surname", "").title()
    nickup = profile.get("nick", "").title()
    wifeup = profile.get("wife", "").title()
    wifenup = profile.get("wifen", "").title()
    kidup = profile.get("kid", "").title()
    kidnup = profile.get("kidn", "").title()
    petup = profile.get("pet", "").title()
    companyup = profile.get("company", "").title()
    
    wordsup = [w.title() for w in profile.get("words", [])]
    # Original 'word' variable for existing logic (lowercase profile words + titlecase profile words)
    word_orig_logic = [w for w in profile.get("words", []) if w] + [wu for wu in wordsup if wu]


    # Reverse names
    rev_name = profile.get("name", "")[::-1]
    rev_nameup = nameup[::-1]
    # ... and so on for other reversed names. Keep this simple or make it more robust.
    reverse_base_list = [profile.get(k, "") for k in ["name", "nick", "wife", "kid"]]
    reverse = []
    for item in reverse_base_list:
        if item:
            reverse.append(item[::-1])
            reverse.append(item.title()[::-1])
    reverse = list(set(filter(None, reverse)))
    
    # Simplified date combinations (bds, wbdss, kbdss)
    # Create a helper for this
    def get_date_combinations(dd, mm, yy, yyyy):
        parts = [p for p in [dd, mm, yy, yyyy] if p] # Only non-empty parts
        combs = []
        if not parts: return [""] # Return list with one empty string if no date parts
        
        combs.extend(parts) # Single parts
        for i in range(len(parts)):
            for j in range(len(parts)):
                if i != j:
                    combs.append(parts[i] + parts[j]) # Two parts
        # Add three-part combinations if needed, but can grow large
        # For now, stick to 1 and 2 part combinations for simplicity
        return list(set(combs)) if combs else [""]

    bds_list = get_date_combinations(birthdate_dd, birthdate_mm, birthdate_yy, birthdate_yyyy)
    wbds_list = get_date_combinations(wifeb_dd, wifeb_mm, wifeb_yy, wifeb_yyyy)
    kbds_list = get_date_combinations(kidb_dd, kidb_mm, kidb_yy, kidb_yyyy)


    # Simplified kombinaXX lists (kombina, kombinaw, ...)
    # Collect all relevant name-like fields
    kombina_all_base = []
    for key in ["name", "surname", "nick", "pet", "company", "wife", "wifen", "kid", "kidn"]:
        val = profile.get(key, "")
        if val:
            kombina_all_base.append(val)
            kombina_all_base.append(val.title())
    kombina_all_base.extend(word_orig_logic) # Add keywords (lower and title)
    kombina_all_base = list(set(filter(None, kombina_all_base))) # Unique, non-empty


    kombi = {} # For original CUPP combinations
    
    # Simplified combinations - focus on core elements
    # Example: Base words + Date parts, Base words + Years
    if kombina_all_base and bds_list != [""]:
        kombi[1] = list(komb(kombina_all_base, bds_list))
        kombi[1].extend(komb(kombina_all_base, bds_list, "_"))
    else: kombi[1] = []
    
    if kombina_all_base and years:
        kombi[4] = list(komb(kombina_all_base, years))
        kombi[4].extend(komb(kombina_all_base, years, "_"))
    else: kombi[4] = []
    
    # Add wife's and kid's date combinations if they exist
    if kombina_all_base and wbds_list != [""]:
         kombi[2] = list(komb(kombina_all_base, wbds_list)) # Using kombina_all_base for simplicity
         kombi[2].extend(komb(kombina_all_base, wbds_list, "_"))
    else: kombi[2] = []

    if kombina_all_base and kbds_list != [""]:
         kombi[3] = list(komb(kombina_all_base, kbds_list))
         kombi[3].extend(komb(kombina_all_base, kbds_list, "_"))
    else: kombi[3] = []


    # Random numbers with base words
    if profile.get("randnum") == "y" and kombina_all_base:
        kombi[12] = list(concats(kombina_all_base, numfrom, numto))
    else: kombi[12] = []

    # Special characters with base words
    komb001 = []
    if profile.get("spechars1") == "y" and profile_spechars and kombina_all_base:
        komb001 = list(komb(kombina_all_base, profile_spechars))


    print("[+] Sorting list and removing duplicates...")
    
    uniqlist = []
    # Add from original kombi structure
    for i in [1, 2, 3, 4, 12]: # Only populated keys
        if i in kombi:
            uniqlist.extend(kombi[i])
    uniqlist.extend(komb001)
    
    # Add base elements themselves
    uniqlist.extend(kombina_all_base)
    uniqlist.extend(bds_list)
    uniqlist.extend(wbds_list)
    uniqlist.extend(kbds_list)
    uniqlist.extend(reverse)
    uniqlist.extend(years) # Add raw years

    # Add passwords generated by new custom logic to the main list
    uniqlist.extend(custom_generated_passwords)
    
    unique_lista = list(set(filter(None, uniqlist))) # Remove empty strings and get unique

    unique_leet = []
    if profile.get("leetmode") == "y":
        for x_word in unique_lista:
            unique_leet.append(make_leet(x_word))
    
    unique_list_final = list(set(unique_lista + unique_leet))

    unique_list_finished = [
        x for x in unique_list_final
        if cfg_global["wcfrom"] <= len(x) <= cfg_global["wcto"]
    ]
    unique_list_finished = [x for x in unique_list_finished if x] # Ensure no empty strings

    if unique_list_finished:
        output_filename = profile.get("name", "output") + ".txt"
        print_to_file(output_filename, unique_list_finished)
    else:
        print("[-] No words generated that match the criteria. Output file not created.")

def download_http(url, targetfile):
    print(f"[+] Downloading {os.path.basename(targetfile)} from {url} ... ", end="", flush=True)
    try:
        with urllib.request.urlopen(url) as webFile, open(targetfile, "wb") as localFile:
            localFile.write(webFile.read())
        print("Done.")
    except urllib.error.URLError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

def alectodb_download():
    """Download csv from alectodb and save into local file as a list of
    usernames and passwords"""
    url = CONFIG["global"]["alectourl"]
    if not url:
        print("[!] AlectoDB URL not configured in cupp.cfg. Skipping.")
        return

    print("\r\n[+] Checking if alectodb is not present...")
    targetfile = "alectodb.csv.gz"

    if not os.path.isfile(targetfile):
        download_http(url, targetfile)
    
    if not os.path.isfile(targetfile):
        print(f"[!] Failed to download or find {targetfile}. Exiting AlectoDB processing.")
        return

    usernames, passwords = [], []
    try:
        with gzip.open(targetfile, "rt", encoding='utf-8', errors='ignore') as f:
            data = csv.reader(f)
            for i, row in enumerate(data):
                if i == 0: continue # Skip header row if present
                if len(row) > 6:
                    usernames.append(row[5])
                    passwords.append(row[6])
    except FileNotFoundError:
        print(f"[!] {targetfile} not found. Cannot process AlectoDB.")
        return
    except gzip.BadGzipFile:
        print(f"[!] {targetfile} is not a valid GZIP file or is corrupted.")
        return
    except Exception as e:
        print(f"[!] Error processing AlectoDB: {e}")
        return

    gus = sorted(list(set(filter(None, usernames))))
    gpa = sorted(list(set(filter(None, passwords))))

    print("\r\n[+] Exporting to alectodb-usernames.txt and alectodb-passwords.txt")
    try:
        with open("alectodb-usernames.txt", "w", encoding='utf-8') as f_user:
            f_user.write(os.linesep.join(gus))
        with open("alectodb-passwords.txt", "w", encoding='utf-8') as f_pass:
            f_pass.write(os.linesep.join(gpa))
        print("[+] Done.")
    except IOError as e:
        print(f"[!] Error writing AlectoDB output files: {e}")

def download_wordlist():
    """Implementation of -l switch. Download wordlists from http repository."""
    dict_repo_url = CONFIG["global"]["dicturl"]
    if not dict_repo_url:
        print("[!] Dictionary repository URL not configured in cupp.cfg. Skipping download.")
        return

    # (Keep the menu print and input logic as before)
    print("	\r\n	Choose the section you want to download:\r\n")
    print("     1   Moby            14      french          27      places")
    # ... (rest of the menu) ...
    print("    13   finnish         26      norwegian       38      exit program\r\n")
    print(f"	\r\n	Files will be downloaded from {dict_repo_url} repository")
    print("	\r\n	Tip: After downloading wordlist, you can improve it with -w option\r\n")

    filedown_str = ""
    while True:
        filedown_str = input("> Enter number (1-38): ").strip()
        if filedown_str.isdigit():
            filedown_int = int(filedown_str)
            if 1 <= filedown_int <= 38:
                break
        print("\r\n[-] Wrong choice. Please enter a number between 1 and 38.")

    if int(filedown_str) == 38:
        print("[-] Exiting program.")
        sys.exit()
    
    download_wordlist_http(filedown_str, dict_repo_url) # Pass repo_url
    # return filedown_str # Not used currently

def download_wordlist_http(filedown_choice_str, base_repo_url):
    """ do the HTTP download of a wordlist """
    mkdir_if_not_exists("dictionaries")
    arguments = { # (Keep the arguments dictionary as before)
        1: ("Moby", ("mhyph.tar.gz", "mlang.tar.gz", "moby.tar.gz", "mpos.tar.gz", "mpron.tar.gz", "mthes.tar.gz", "mwords.tar.gz")),
        # ... (all other entries)
        37: ("yiddish", ("yiddish.gz",)),
    }

    intfiledown = int(filedown_choice_str)
    if intfiledown in arguments:
        category_name, files_to_dl = arguments[intfiledown]
        # Ensure base_repo_url ends with a slash
        if not base_repo_url.endswith('/'):
            base_repo_url += '/'
        
        # Category path might also need a slash if not present in arguments[intfiledown][0]
        category_dir_name = category_name # For local directory
        if category_name.endswith('/'): # If category from dict has trailing slash
             category_url_part = category_name
        else:
             category_url_part = category_name + '/'


        target_dir = os.path.join("dictionaries", category_dir_name)
        mkdir_if_not_exists(target_dir)

        for fi in files_to_dl:
            url = base_repo_url + category_url_part + fi
            tgt_file_path = os.path.join(target_dir, fi)
            download_http(url, tgt_file_path)
        print(f"[+] Files saved to {target_dir}")
    else:
        print("[-] Invalid selection for download (should not happen with validation).")

def mkdir_if_not_exists(dir_path):
    if not os.path.isdir(dir_path):
        try:
            os.makedirs(dir_path, exist_ok=True) # exist_ok=True is helpful
        except OSError as e:
            print(f"[!] Error creating directory {dir_path}: {e}")

def main():
    script_dir = os.path.dirname(os.path.realpath(__file__))
    config_file_path = os.path.join(script_dir, "cupp.cfg")
    
    if not read_config(config_file_path):
        return # read_config exits on failure

    parser = get_parser()
    args = parser.parse_args()

    if not args.quiet:
        print("\r\n	\033[1;31mCommon User Passwords Profiler (CUPP)\033[1;m\r\n")

    if args.version:
        version()
    elif args.interactive:
        interactive()
    elif args.download_wordlist:
        download_wordlist()
    elif args.alecto:
        alectodb_download()
    elif args.improve:
        improve_dictionary(args.improve)
    else:
        if len(sys.argv) == 1 or (len(sys.argv) == 2 and args.quiet):
             parser.print_help()
             sys.exit(1)

def get_parser():
    parser = argparse.ArgumentParser(
        description="Common User Passwords Profiler (CUPP)\n"
                    "Generates targeted password lists based on user information.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument(
        "-i", "--interactive", action="store_true",
        help="Interactive mode: Answer questions to build a profile."
    )
    group.add_argument(
        "-w", dest="improve", metavar="FILENAME",
        help="Improve an existing wordlist (FILENAME) with CUPP's transformations."
    )
    group.add_argument(
        "-l", dest="download_wordlist", action="store_true",
        help="Download pre-compiled wordlists from a repository."
    )
    group.add_argument(
        "-a", dest="alecto", action="store_true",
        help="Download and parse default credentials from the Alecto DB project."
    )
    group.add_argument(
        "-v", "--version", action="store_true",
        help="Show program version and exit."
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true",
        help="Quiet mode: Suppress the startup banner."
    )
    return parser

if __name__ == "__main__":
    main()
